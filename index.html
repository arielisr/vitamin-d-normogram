<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Vitamin D Calendar Adjustment</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<style>
:root{
  --bg:#ffffff; --card:#fff; --ink:#1f2937; --muted:#6b7280;
  --fieldw: 6ch;           /* compact inputs */
  --coefw: 110px;           /* coefficient field width */
  --wrapw: 1100px;          /* page width */
}

/* Page + wraps */
body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; color:var(--ink); background:#ffffff; }
.wrap{ max-width:var(--wrapw); margin:0 auto; padding:0 16px; }
.wrap.wrap--banner{ margin-top:4px !important; }
.wrap + .wrap{ margin-top:0 !important; margin-bottom:0 !important; }
.card{ background:var(--card); border-radius:14px; box-shadow:0 6px 20px rgba(0,0,0,.06); padding:16px; margin:0; }

/* Banner */
.banner-wrap{ position:relative; }
.hero{ width:100%; height:auto; display:block; border-radius:10px; }
.banner-title{
  position:absolute; left:50%; top:30%; transform:translate(-50%,-50%);
  color:#fff; font-weight:700; text-align:center; line-height:1.15;
  text-shadow:0 2px 8px rgba(0,0,0,.45);
  font-size:clamp(20px,3vw,40px);
  padding:6px 10px; pointer-events:none; white-space:pre-wrap;
}
@media (max-width:480px){
  .banner-title{
    font-size:clamp(14px,4vw,20px); /* lower max on small screens */
    line-height:1.1;                /* tighten lines a bit */
    padding:4px 8px;                /* trim padding */
    max-width:92vw;                 /* avoid long wraps */
    white-space:normal;             /* let it wrap more naturally */
    text-wrap:balance;              /* nicer line breaks where supported */
  }
}
/* Phone in landscape: keep each banner ≤15% of viewport height */
@media (max-width: 820px) and (orientation: landscape) {
  .banner-wrap .hero,
  .footer-ribbon {
    max-height: 15vh;     /* key cap */
    width: 100%;
    height: auto;         /* respect intrinsic ratio */
    object-fit: cover;    /* crop gracefully if container forces height */
    border-radius: 10px;
  }

  /* Keep the title readable when the banner is shorter */
  .banner-title{
    top: 24%;                           /* a bit higher */
    font-size: clamp(14px, 2.2vw, 24px);
    padding: 4px 6px;
  }

  /* Keep the language selector inside the shorter banner */
  .banner-lang { top: 6px; right: 10px; }
}

.banner-lang{ position:absolute; top:8px; right:12px; z-index:2; }
.banner-lang select{
  font-size:14px; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px;
  background:rgba(255,255,255,0.9); backdrop-filter:blur(2px);
}
.visually-hidden{ position:absolute!important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

/* Neutralize any legacy grid wrapper so it doesn't affect layout */
.grid-top{ display:contents; }

/* Fields */
.field{ display:flex; flex-direction:column; align-items:flex-start; min-width:0; }
.field label{ font-size:13px; color:var(--muted); margin-bottom:4px; }
.field input[type="number"],
.field input[type="date"]{
  width:var(--fieldw); max-width:100%; font-size:16px; padding:6px 8px;
  border:1px solid #e5e7eb; border-radius:10px; font-variant-numeric:tabular-nums; font-feature-settings:"tnum" 1;
}
.field input[type="date"]{ width:115px; }
.hint{ color:var(--muted); font-size:12px; margin-top:4px; white-space:nowrap;}

/* Toolbar: single line; scrolls horizontally if too tight (no overlap) */
.toolbar.one-line{
  display:flex; align-items:flex-end; gap:12px;
  flex-wrap:nowrap; overflow-x:auto; -webkit-overflow-scrolling:touch;
  justify-content: center; 
}

/* Keep children from shrinking into each other */
.toolbar.one-line > .field{ flex:0 0 auto; min-width:0; }

/* Lock the value + radios together on ONE line as a single chunk */
.field-row{
  display:inline-grid;
  grid-auto-flow:column;
  grid-auto-columns:max-content;
  align-items:end;
  gap:8px;
  white-space:nowrap;  
}
.field--date{
  margin-inline-start: 10px;
}

/* mirror for RTL */
html[dir="rtl"] .field--date{
  margin-inline-start: 0;
  margin-inline-end: 10px;
}
/* Radios inline, no wrap */
.radio {
  display: inline-flex;
  flex-direction: column;
  align-items: flex-start; 
  gap: 2px;
}
.radio label{ white-space:nowrap; display:flex; align-items:center; }

/* Canvas/footer */
canvas{ width:100%; height:auto; background:#fff; border-radius:12px; display:block; }
.footer-ribbon{ width:100%; display:block; margin-top:0px; border-radius:10px; }
/* RTL minor tweaks */
html[dir="rtl"] .toolbar.one-line{ direction:rtl; }

/* Modal shell */
.vd-modal {
  position: fixed; inset: 0; display: none; /* no flex-centering; JS will pin to VV */
  background: rgba(0,0,0,.4); z-index: 9999;
}
.vd-modal[aria-hidden="false"] { display: flex; }
.vd-dialog {
  position: fixed;           /* pin to visual viewport via JS */
  left: 50vw; top: 50vh;     /* fallback center if VV not supported */
  transform: translate(-50%,-50%);
  width: min(92vw, 420px);
  background: #fff; color:#111; border-radius: 14px;
  box-shadow: 0 10px 30px rgba(0,0,0,.25); overflow: hidden;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
  will-change: transform, top, left;
}
.vd-header {
  display:flex; align-items:center; justify-content:space-between;
  padding: 10px 14px; background:#f6f7fb; border-bottom:1px solid #e5e7eb;
  font-weight:600;
}
.vd-close { background:none; border:0; font-size:20px; line-height:1; padding:6px; cursor:pointer; }
.vd-body { padding: 16px; }
.vd-value { text-align:center; font-size: 22px; margin-bottom: 10px; }
#vitd-slider { width: 100%; }
.vd-actions {
  display:flex; gap:8px; justify-content:center; margin-top:14px;
}
.vd-actions button {
  padding:10px 14px; border-radius:10px; border:1px solid #e5e7eb; background:#fff; font-size:16px;
}
.vd-primary { background:#111; color:#fff; border-color:#111; }
/* value row: keep input+radios on one line */
.value-row{
  display:flex;
  align-items:flex-end;   /* bottom-align input with radios */
  gap:0px;
  flex-wrap:nowrap;       /* do not wrap when there is room */
}

/* the small column that holds the label + input (+ hint) */
.input-col{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  min-width:0;
}

/* reuse your compact input width */
.input-col input[type="number"]{
  width:var(--fieldw);
}

/* radios slightly aside but same line */
.value-row .radio{
  display:flex;
  flex-direction:column;  /* your vertical arrangement */
  gap:2px;
  margin-inline-start:8px;  /* a bit of breathing room from the input */
}

/* tighten the label above the input only */
.input-col > label{
  font-size:13px;
  color:var(--muted);
  margin-bottom:4px;
}

/* keep hint under the input and prevent it from stretching layout */
.input-col .hint{
  margin-top:4px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  max-width:22ch;
}

/* RTL support inherits naturally; if you want mirrored spacing: */
html[dir="rtl"] .value-row .radio{
  margin-inline-start:0;
  margin-inline-end:8px;
}

/* On very narrow screens allow wrap, but keep input+label together */
@media (max-width:520px){
  .value-row{ flex-wrap:wrap; }
  .value-row .radio{ order:2; }     /* radios drop under if needed */
}

@media (max-width: 640px){
  html, body { margin:0; padding:0; }

  /* Kill container gutters and width caps */
  .wrap, .container, .section {
    max-width: none;
    padding: 0;
    margin: 0;
  }

  /* Respect iOS notches when you DO want tiny side gutters */
  .wrap, .container, .section, header, footer {
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
  }

  /* Optional: make specific blocks bleed full width */
  .fullbleed {
    width: 100vw;
    margin-left: calc(50% - 50vw);
    margin-right: calc(50% - 50vw);
  }

  /* If your banner had inner padding, trim it */
  .banner, .banner-title { padding-left: 0; padding-right: 0; }
  
}
</style>
</head>
<script>window.process = window.process || { env: {} };</script>
<script type="module">
  import { initializeApp }     from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import { getAnalytics, isSupported, logEvent, setUserProperties }
    from "https://www.gstatic.com/firebasejs/10.12.4/firebase-analytics.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCrm86rYfHXbe2gpzDbvkl2wEWnzcDqi28",
    authDomain: "arielisr.github.io",
    projectId: "vitamin-d-normogram",
    storageBucket: "covidest.appspot.com",
    messagingSenderId: "1028167923136",
    appId: "1:1028167923136:web:1ca1fc0177ebd0d3b70425",
    measurementId: "G-8HCTDJGBS1"
  };

  const app = initializeApp(firebaseConfig);

  // Guard: analytics only on supported, secure origins
  const analytics = (await isSupported()) ? getAnalytics(app) : null;

  // Helper safe-log
  function log(name, params){ if (analytics) logEvent(analytics, name, params); }

  // Set useful user properties (no PII)
  const langSel = document.getElementById('langSel');
  if (analytics && langSel) {
    setUserProperties(analytics, { ui_lang: langSel.value });
    langSel.addEventListener('change', () => setUserProperties(analytics, { ui_lang: langSel.value }));
  }

  // Log initial page_view (GA4 usually auto-logs; harmless to send once)
  log('page_view', { page_title: document.title });

  // Example: log interactions (hook into your existing inputs)
  const vitInput = document.getElementById('vitd');
  const dateInput = document.getElementById('measureDate');
  const unitRadios = document.querySelectorAll('input[name="unit"]');

  vitInput?.addEventListener('change', () => log('vitd_value_change', {
    value_ng_or_nmol: parseFloat(vitInput.value) || 0
  }));
  dateInput?.addEventListener('change', () => log('measurement_date_change', {}));
  unitRadios.forEach(r => r.addEventListener('change', (e) => log('unit_toggle', { unit: e.target.value })));

  // Optional: log each redraw (keep params small, no PII)
  window._logPlotUpdate = (params) => log('plot_update', params);
</script>

<body>

  <!-- Banner with title and language switch -->
  <div class="wrap wrap--banner">
    <div class="banner-wrap">
      <img class="hero" alt="Leumit Research banner" src="https://arielisr.github.io/lri-newsletter/graphics/leumit_banner_300DPI.png">
      <div class="banner-title" id="bannerTitle">Vitamin D Calendar Adjustment</div>
      <div class="banner-lang">
        <label for="langSel" class="visually-hidden">Language</label>
        <select id="langSel" aria-label="Language">
          <option value="en">English</option>
          <option value="he">עברית</option>
        </select>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="toolbar one-line">
<div class="field field--value">
  <div class="value-row" dir="ltr">
    <div class="input-col">
      <label id="lblValue">25(OH)D value</label>
      <input id="vitd" type="number" min="0" max="70" step="1" value="25" inputmode="decimal">
      <div class="hint" id="unitHint">= 50.0 nmol/L</div>
    </div>

    <div class="radio" id="unitGroup">
      <label><input type="radio" name="unit" value="ng" checked> <span id="unitNg">ng/mL</span></label>
      <label><input type="radio" name="unit" value="nmol"> <span id="unitNmol">nmol/L</span></label>
    </div>
  </div>
</div>
<!-- Modal slider -->
	<div id="vitd-modal" class="vd-modal" aria-hidden="true" role="dialog" aria-labelledby="vd-title">
	  <div class="vd-dialog">
		<div class="vd-header">
		  <div id="vd-title">Set Vitamin D</div>
		  <button type="button" class="vd-close" aria-label="Close">X</button>
		</div>

		<div class="vd-body">
		  <div class="vd-value"><span id="vd-live">25</span> <span id="vd-unit-label">ng/mL</span></div>
		  <input id="vitd-slider" type="range" dir="ltr" min="0" max="70" step="1" value="25" list="vd-ticks">
		  <datalist id="vd-ticks" dir="ltr"></datalist>
		  <div class="vd-actions">
			<button type="button" id="vd-dec">-</button>
			<button type="button" id="vd-inc">+</button>
			<button type="button" id="vd-ok" class="vd-primary">OK</button>
		  </div>
		</div>
	  </div>
	</div>
<div class="field field--date">
  <label id="lblDate">Date of measurement</label>
  <input id="measureDate" type="date">
  <div class="hint" id="hintDate">Anchors the seasonal curve</div>
</div>
    </div>

      <details hidden>
        <summary id="advTitle">Advanced: seasonal coefficients</summary>
        <div class="coef-grid" style="margin-top:8px;">
          <div class="coef"><label id="coef_const">const</label>        <input id="p_const" type="number" step="0.000001" value="2.86504436"></div>
          <div class="coef"><label id="coef_sin1">season_sin</label>    <input id="p_sin1"  type="number" step="0.000001" value="-0.19078822"></div>
          <div class="coef"><label id="coef_cos1">season_cos</label>    <input id="p_cos1"  type="number" step="0.000001" value="-0.17079543"></div>
          <div class="coef"><label id="coef_sin2">season_sin2</label>   <input id="p_sin2"  type="number" step="0.000001" value="0.01443204"></div>
          <div class="coef"><label id="coef_cos2">season_cos2</label>   <input id="p_cos2"  type="number" step="0.000001" value="0.00978268"></div>
        </div>
        <div class="hint" id="advHint">Curve = exp(const + a·sin(θ) + b·cos(θ) + c·sin(2θ) + d·cos(2θ)), θ=2π·day/365.25. Your input rescales the curve at the chosen date.</div>
      </details>
      <canvas id="plot" width="1200" height="520"></canvas>
      <div class="hint" id="bandsHint">Bands: Very-severe &lt;5, Severe 5–10, Moderate 10–15, Mild 15–20, Insufficiency 20–30, Sufficiency ≥30 ng/mL</div>
  </div>
  <div class="wrap wrap--banner">
    <img class="footer-ribbon" alt="Leumit Research Institute ribbon" src="https://arielisr.github.io/lri-newsletter/graphics/leumit_tailer_300DPI.png">
  </div>

<script>
const LRI = "\u2066";   // start LTR isolate
const PDI = "\u2069";   // pop directional isolate
const NBSP = "\u00A0";

/* ---------- i18n strings ---------- */
const STR = {
  en: {
    docTitle: 'Vitamin D Calendar Adjustment',
    bannerTitle: 'Vitamin D Calendar Adjustment',
    lblValue: '25(OH)D value',
    unitNg: 'ng/mL',
    unitNmol: 'nmol/L',
    lblDate: 'Date of measurement',
    hintDate: 'Anchors the seasonal curve',
    advTitle: 'Advanced: seasonal coefficients',
    advHint: 'Curve = exp(const + a·sin(θ) + b·cos(θ) + c·sin(2θ) + d·cos(2θ)), θ=2π·day/365.25. Your input rescales the curve at the chosen date.',
    coef_const: 'const',
    coef_sin1: 'season_sin',
    coef_cos1: 'season_cos',
    coef_sin2: 'season_sin2',
    coef_cos2: 'season_cos2',
    bandsHint: 'Bands: Very-severe <5, Severe 5–10, Moderate 10–15, Mild 15–20, Insufficiency 20–30, Sufficiency ≥30 ng/mL',
    bands: [
      { key:'verySevere', label:'Very-severe deficiency' },
      { key:'severe',     label:'Severe deficiency' },
      { key:'moderate',   label:'Moderate deficiency' },
      { key:'mild',       label:'Mild deficiency' },
      { key:'insuff',     label:'Insufficiency' },
      { key:'suff',       label:'Sufficiency' }
    ],
    axisX: 'Day of year',
    axisY: '25-OH Vitamin D (ng/mL)',
    nadir: 'Nadir'
  },
  he: {
    docTitle: 'ויטמין די מתוקן לתאריך',
    bannerTitle: 'ויטמין די מתוקן לתאריך',
    lblValue: `${LRI}25(OH)D${PDI}`,
    unitNg: 'ng/mL',
    unitNmol: 'nnmol/L',
    lblDate: 'תאריך המדידה',
    hintDate: 'מעגן את העקומה העונתית',
    advTitle: 'מתקדם: מקדמי עונתיות',
    advHint: 'עקומה = exp(const + a·sin(θ) + b·cos(θ) + c·sin(2θ) + d·cos(2θ)), ‏θ=2π·יום/365.25. הערך שהוזן מתאים את העקומה לתאריך.',
    coef_const: 'const',
    coef_sin1: 'season_sin',
    coef_cos1: 'season_cos',
    coef_sin2: 'season_sin2',
    coef_cos2: 'season_cos2',
    bandsHint: 'תחומים: חוסר חמור מאוד <5, חוסר חמור 5–10, חוסר בינוני 10–15, חוסר קל 15–20, חוסר 20–30, מספק ≥30 נג/מ״ל',
    bands: [
      { key:'verySevere', label:'חוסר חמור מאוד' },
      { key:'severe',     label:'חוסר חמור' },
      { key:'moderate',   label:'חוסר בינוני' },
      { key:'mild',       label:'חוסר קל' },
      { key:'insuff',     label:'חוסר' },
      { key:'suff',       label:'מספק' }
    ],
    axisX: 'יום בשנה',
    axisY: '25-OH ויטמין D (נג/מ״ל)',
    nadir: 'שפל'
  }
};

/* ---------- locale helpers ---------- */
function getInitialLang(){
  const urlLang = new URLSearchParams(location.search).get('lang');
  if (urlLang === 'he' || urlLang === 'en') return urlLang;
  return (navigator.language || '').toLowerCase().startsWith('he') ? 'he' : 'en';
}
let LANG = getInitialLang();

function applyLang(lang){
  LANG = (lang === 'he') ? 'he' : 'en';
  const S = STR[LANG];
  document.documentElement.lang = LANG;
  document.documentElement.dir  = (LANG === 'he') ? 'rtl' : 'ltr';
  document.title = S.docTitle;

  const set = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = v; };
  set('bannerTitle', S.bannerTitle);
  set('lblValue', S.lblValue);
  set('unitNg', S.unitNg);
  set('unitNmol', S.unitNmol);
  set('lblDate', S.lblDate);
  set('hintDate', S.hintDate);
  set('advTitle', S.advTitle);
  set('advHint', S.advHint);
  set('coef_const', S.coef_const);
  set('coef_sin1', S.coef_sin1);
  set('coef_cos1', S.coef_cos1);
  set('coef_sin2', S.coef_sin2);
  set('coef_cos2', S.coef_cos2);
  set('bandsHint', S.bandsHint);

  const sel = document.getElementById('langSel');
  if (sel && sel.value !== LANG) sel.value = LANG;

  updateUnitHint();
  draw();
}

/* ---------- plotting utilities ---------- */
function maxArr(arr, fallback = 0){
  if (Array.isArray(arr) && arr.length) {
    let m = arr[0];
    for (let i=1; i<arr.length; i++) if (arr[i] > m) m = arr[i];
    return m;
  }
  return fallback;
}

// Global plot mapping saved by draw()
const plotState = {
  x0: 0, x1: 0, y0: 0, y1: 0,
  yMin: 0, yMax: 45
};

function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }

// Convert DOY to yyyy-mm-dd string (local time) for current year
function dateStrFromDoy(doy){
  const year = new Date().getFullYear();
  const d = new Date(year, 0, 1);
  d.setDate(d.getDate() + (doy - 1));
  const mm = String(d.getMonth()+1).padStart(2,'0');
  const dd = String(d.getDate()).padStart(2,'0');
  return `${year}-${mm}-${dd}`;
}

const toNmol = ng => ng * 2.5;
const toNg   = nmol => nmol / 2.5;

function dayOfYear(d){
  const dt = new Date(d.getFullYear(), 0, 0);
  const diff = d - dt + ((dt.getTimezoneOffset()-d.getTimezoneOffset())*60*1000);
  return Math.floor(diff / (1000*60*60*24)); // 1..366
}
function dateFmtMonthDay(date){
  return new Intl.DateTimeFormat(LANG, { month: 'short', day: 'numeric' }).format(date);
}
function monthLabelFor(monthIndex, year){
  const d = new Date(year, monthIndex, 1);
  return new Intl.DateTimeFormat(LANG, { month: 'short' }).format(d);
}

function buildSeason(days, p){
  const out = new Array(days.length);
  for (let i=0;i<days.length;i++){
    const t = days[i];
    const theta = 2*Math.PI*t/365.25;
    const valLog = p.const + p.sin1*Math.sin(theta) + p.cos1*Math.cos(theta)
                 + p.sin2*Math.sin(2*theta) + p.cos2*Math.cos(2*theta);
    out[i] = Math.exp(valLog);
  }
  return out;
}
function deviceScale(canvas, ctx){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  canvas.width  = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}

/* ---------- drawing ---------- */
const cv = document.getElementById('plot');
// REPLACE the whole listener with this:
cv.addEventListener('click', (e) => {
  const r  = cv.getBoundingClientRect();
  const px = e.clientX - r.left;
  const py = e.clientY - r.top;

  const { x0, x1, y0, y1, yMin, yMax, daysMax = 365 } = plotState;
  // ignore clicks outside the plot area
  if (px < x0 || px > x1 || py < y0 || py > y1) return;

  // map X to day-of-year (1..daysMax)
  const day = Math.max(1, Math.min(
    daysMax,
    Math.round(1 + (px - x0) / (x1 - x0) * (daysMax - 1))
  ));

  // map Y pixel to value INDEPENDENT of the curve
  const frac  = (y1 - py) / (y1 - y0);          // 0..1 bottom->top
  const valNg = Math.min(yMax, Math.max(yMin, yMin + frac * (yMax - yMin)));

  // update inputs (in the currently selected unit)
  const unit      = document.querySelector('input[name="unit"]:checked')?.value || 'ng';
  const vitInput  = document.getElementById('vitd');        // number field
  const dateInput = document.getElementById('measureDate'); // date field

  if (vitInput) {
    const v = (unit === 'ng') ? valNg : (valNg * 2.5);
    vitInput.value = Math.max(0, +v.toFixed(1));
    vitInput.dispatchEvent(new Event('input',  { bubbles: true }));
    vitInput.dispatchEvent(new Event('change', { bubbles: true }));
  }
  if (dateInput) {
    dateInput.value = dateStrFromDoy(day);
    dateInput.dispatchEvent(new Event('change', { bubbles: true }));
  }

  // refresh the "= xx nmol" hint if you show it
  if (typeof updateUnitHint === 'function') updateUnitHint();
  // draw() will be called by the change handlers; call explicitly if needed:
  if (typeof draw === 'function') draw();
});

const ctx = cv.getContext('2d');

const PHONE_BP = 640; // px

function sizeCanvasForViewport() {
  const rect = cv.getBoundingClientRect();
  const vw   = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  const vh   = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

  // Available vertical space under the top of the canvas (accounts for banner/toolbar already)
  const keyboardInset = window.visualViewport ? (window.visualViewport.height - window.innerHeight) : 0;
  const remaining = Math.max(0, vh - rect.top - 12 - keyboardInset);

  // Simple device buckets
  const isPhone        = window.matchMedia('(max-width: 640px)').matches;
  const isTablet       = window.matchMedia('(min-width: 641px) and (max-width: 1024px)').matches;
  const isLandscape    = window.matchMedia('(orientation: landscape)').matches;

  // width-based aspect cap so the plot does not get too squat on wide screens
  // 0.58 roughly ~ 16:9 to 3:2 feel; tweak to taste
  const widthAspectCap = Math.round(vw * 0.58);

  let targetH;

  if (isPhone) {
    if (isLandscape) {
      // Phone landscape: keep modest height so banners + toolbar still fit
      targetH = Math.min(
        Math.round(vh * 0.55),
        Math.round(remaining * 0.70),
        widthAspectCap
      );
      targetH = clamp(targetH, 200, 360);
    } else {
      // Phone portrait
      targetH = Math.min(
        Math.round(vh * 0.60),
        Math.round(remaining * 0.65),
        widthAspectCap
      );
      targetH = clamp(targetH, 260, 420);
    }
  } else if (isTablet) {
    // Tablets: give more room
    targetH = Math.min(
      Math.round(vh * 0.68),
      Math.round(remaining * 0.80),
      Math.round(vw * 0.60) // aspect guard
    );
    targetH = clamp(targetH, 360, 560);
  } else {
    // Desktops/laptops
    targetH = Math.min(
      Math.round(vh * 0.72),  // use a good chunk of viewport height
      Math.round(remaining * 0.90),
      Math.round(vw * 0.58)   // width-aspect guard
    );
    targetH = clamp(targetH, 420, 720);
  }

  // Never exceed the actual remaining space
  targetH = Math.min(targetH, remaining);

  cv.style.height = `${targetH}px`;
  draw();
}


// call this instead of calling sizeCanvasForViewport() directly
function relayoutCanvas() {
  // 3 passes: now, next frame, and a short delay (for late assets)
  sizeCanvasForViewport();
  requestAnimationFrame(sizeCanvasForViewport);
  setTimeout(sizeCanvasForViewport, 250);
}

// Run after DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  relayoutCanvas();

  // After all resources (images, CSS) load
  window.addEventListener('load', relayoutCanvas);

  // Fonts can cause reflow after they finish loading
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(relayoutCanvas).catch(()=>{});
  }

  // Banner image can shift layout: re-run when it finishes
  const hero = document.querySelector('.hero');
  if (hero) {
    if (hero.complete) {
      // already loaded
      relayoutCanvas();
    } else {
      hero.addEventListener('load', relayoutCanvas, { once: true });
      hero.addEventListener('error', relayoutCanvas, { once: true });
    }
  }
// Also relayout when the footer ribbon loads
const footer = document.querySelector('.footer-ribbon');
if (footer) {
  if (footer.complete) {
    relayoutCanvas();
  } else {
    footer.addEventListener('load',  relayoutCanvas, { once: true });
    footer.addEventListener('error', relayoutCanvas, { once: true });
  }
}

// On orientation change, recalc after the UI settles
window.addEventListener('orientationchange', () => {
  // two passes to survive address-bar jiggles on mobile
  relayoutCanvas();
  setTimeout(relayoutCanvas, 250);
});

  // Re-run on viewport changes (address bar show/hide on mobile)
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', relayoutCanvas);
    window.visualViewport.addEventListener('scroll', relayoutCanvas);
  }

  // Fallback: general window resizes
  window.addEventListener('resize', relayoutCanvas);

  // If your UI toggles language/units or changes text length, also hook them:
  document.getElementById('langSel')?.addEventListener('change', relayoutCanvas);
  document.getElementById('unitGroup')?.addEventListener('change', relayoutCanvas);

  // Observe layout changes above the canvas (cards expanding, etc.)
  const aboveCanvas = document.querySelector('.card'); // or a container above your canvas
  const ro = new ResizeObserver(relayoutCanvas);
  if (aboveCanvas) ro.observe(aboveCanvas);
});

function isSmallViewport(){
   // small phones in portrait (narrow width) OR phones in landscape (short height)
   return (
     window.matchMedia('(max-width: 560px)').matches ||
     window.matchMedia('(orientation: landscape) and (max-height: 520px)').matches
   );
}
function draw(){
  const S = STR[LANG];
  deviceScale(cv, ctx);
  const W = cv.clientWidth, H = cv.clientHeight;
  const rtl = (LANG === 'he');
  const isSmall = isSmallViewport();
  const m = isSmall ? {l:36, r:16, t:28, b:40} : {l:56, r:140, t:34, b:46};
  const x0 = m.l, x1 = W - m.r, y0 = m.t, y1 = H - m.b;
  const plotW = x1 - x0, plotH = y1 - y0;

  // --- inputs (unit, value, date, coefficients)
  const unitSel = document.querySelector('input[name="unit"]:checked').value;
  const v_in = parseFloat(document.getElementById('vitd').value || '0');
  const v_ng = (unitSel === 'ng') ? v_in : toNg(v_in);   // always compute in ng/mL

  const dateStr = document.getElementById('measureDate').value;
  const d = dateStr ? new Date(dateStr) : new Date();
  const doy = clamp(dayOfYear(d), 1, 365);

  const p = {
    const: parseFloat(document.getElementById('p_const').value || '2.86504436'),
    sin1:  parseFloat(document.getElementById('p_sin1').value  || '-0.19078822'),
    cos1:  parseFloat(document.getElementById('p_cos1').value  || '-0.17079543'),
    sin2:  parseFloat(document.getElementById('p_sin2').value  || '0.01443204'),
    cos2:  parseFloat(document.getElementById('p_cos2').value  || '0.00978268'),
  };

  // --- build base curve and scale it to pass through the input at the chosen date
  const daysMax = 365;
  const days = Array.from({length: daysMax}, (_, i) => i + 1);
  const base = buildSeason(days, p);             // unscaled season (ng/mL)
  const baseAt = base[doy - 1] || 1;
  const scale = v_ng > 0 ? (v_ng / baseAt) : 1;
  const curve = base.map(x => x * scale);
  plotState.curve = curve;   // <-- add this


  // --- y range after curve is known
  const yMin = 0;
  const maxCurve = Math.max(30, maxArr(curve, 30));
  const yMax = Math.max(50, Math.ceil(maxCurve / 5) * 5);

  // save mapping for click handler
  plotState.x0 = x0; plotState.x1 = x1;
  plotState.y0 = y0; plotState.y1 = y1;
  plotState.yMin = yMin; plotState.yMax = yMax;
  plotState.daysMax = daysMax;

  ctx.clearRect(0,0,W,H);
  
  // nadir (projected day)
  let nadirDay = 1, nadirVal = curve[0];
  for (let i=1;i<curve.length;i++){
    if (curve[i] < nadirVal){ nadirVal = curve[i]; nadirDay = i+1; }
  }

  const xMap = x => x0 + (x-1)/(365-1)*plotW;
  const yMap = y => y1 - (y-yMin)/(yMax-yMin)*plotH;

  // background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(x0,y0,plotW,plotH);

  // bands (ng/mL thresholds)
  const bands = [
    {y0:0, y1:5,  key:'verySevere', color:'rgba(200, 30, 30, 0.18)'},
    {y0:5, y1:10, key:'severe',     color:'rgba(220, 60, 40, 0.18)'},
    {y0:10,y1:15, key:'moderate',   color:'rgba(230, 120, 40, 0.18)'},
    {y0:15,y1:20, key:'mild',       color:'rgba(240, 170, 40, 0.18)'},
    {y0:20,y1:30, key:'insuff',     color:'rgba(170, 200, 60, 0.18)'},
    {y0:30,y1:yMax, key:'suff',     color:'rgba(80, 170, 80, 0.14)'}
  ];
  bands.forEach(b=>{
    const yy0 = Math.max(yMin, b.y0), yy1 = Math.min(yMax, b.y1);
    if (yy1<=yy0) return;
    ctx.fillStyle = b.color;
    ctx.fillRect(x0, yMap(yy1), plotW, Math.abs(yMap(yy0)-yMap(yy1)));
  });

  // boundaries
  const boundaries = [5,10,15,20,30];
  boundaries.forEach(y=>{
    if (y<yMin || y>yMax) return;
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x0, yMap(y));
    ctx.lineTo(x1, yMap(y));
    ctx.stroke();
  });

  // grid (y major every 5)
  ctx.strokeStyle = 'rgba(0,0,0,0.08)';
  ctx.lineWidth = 1;
  for (let y=0; y<=yMax; y+=5){
    ctx.beginPath();
    ctx.moveTo(x0, yMap(y));
    ctx.lineTo(x1, yMap(y));
    ctx.stroke();
  }

  // month verticals & centered labels, localized
  const monthStarts = [1,32,60,91,121,152,182,213,244,274,305,335,366];
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.setLineDash([4,5]);
  for (let i=0;i<monthStarts.length-1;i++){
    ctx.beginPath();
    ctx.moveTo(xMap(monthStarts[i]), y0);
    ctx.lineTo(xMap(monthStarts[i]), y1);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // axes: bottom + vertical (left in LTR, right in RTL)
  ctx.strokeStyle = '#111';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  if (rtl) {
    ctx.moveTo(x1, y0); ctx.lineTo(x1, y1); // right vertical axis
  } else {
    ctx.moveTo(x0, y0); ctx.lineTo(x0, y1); // left vertical axis
  }
  ctx.lineTo(x1, y1); // bottom axis
  ctx.stroke();

    // y ticks & labels: left in LTR, right in RTL
  ctx.fillStyle = '#111';
  ctx.font = (isSmall ? '11px' : '12px') + ' system-ui, Arial';
  ctx.textBaseline = 'middle';
  if (rtl) {
    ctx.textAlign = 'left';
    for (let y=0; y<=yMax; y+=5){
      ctx.fillText(String(y), x1 + 6, yMap(y)); // a bit tighter
    }
  } else {
    ctx.textAlign = 'right';
    for (let y=0; y<=yMax; y+=5){
      ctx.fillText(String(y), x0 - 6, yMap(y));
    }
  }

	const el = document.getElementById('bandsHint');
	if (el) el.hidden = !isSmall; 
  // month labels (localized)
  const yearForLabels = (new Date()).getFullYear();
  ctx.textAlign='center'; ctx.textBaseline='top';
  for (let i=0;i<12;i++){
    const center = 0.5*(monthStarts[i] + monthStarts[i+1]);
    const label = monthLabelFor(i, yearForLabels);
    ctx.fillText(label, xMap(center), y1+8);
  }

  // band labels at outer margin (right in LTR, left in RTL)
  if (!isSmall) {
    ctx.textAlign = rtl ? 'right' : 'left';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#111';
    bands.forEach((b, idx)=>{
      const yy = Math.min((b.y0+b.y1)/2, yMax-0.001);
      if (yy<yMin || yy>yMax) return;
      const label = STR[LANG].bands[idx].label;
      const xText = rtl ? (x0-8) : (x1+8);
      ctx.fillText(label, xText, yMap(yy));
    });
  }

  // curve
  ctx.strokeStyle = '#2457a0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i=0;i<days.length;i++){
    const X = xMap(days[i]), Y = yMap(curve[i]);
    if (i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();

  // markers: measurement day & nadir (projected day)
  const Xd = xMap(doy),   Yd = yMap(curve[doy-1]);
  const Xn = xMap(nadirDay), Yn = yMap(nadirVal);
  function dot(x,y, color){ ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); }
  dot(Xd, Yd, '#2457a0');   // measurement (blue)
  dot(Xn, Yn, '#ef4444');   // nadir/projected (red)

  const normalFont = "12px system-ui";
  const boldFont   = "bold 12px system-ui";
  // top-boundary annotations (month-day only; units on separate lines)
  ctx.fillStyle='#111';
  ctx.textAlign='center';
  ctx.textBaseline='top';
  ctx.font=normalFont;
  
  // measurement
  const measDateTxt = dateFmtMonthDay(d);
  const measNgTxt   = `${LRI}${v_ng.toFixed(1)}${NBSP}${STR[LANG].unitNg}${PDI}`;
  const measNmolTxt = `(${LRI}${toNmol(v_ng).toFixed(0)}${NBSP}${STR[LANG].unitNmol}${PDI})`;
  ctx.fillText(measDateTxt, Xd, y0 + 2);
  ctx.font=boldFont;
  ctx.fillText(measNgTxt,   Xd, y0 + 16);
  ctx.font=normalFont;
  ctx.fillText(measNmolTxt, Xd, y0 + 30);

  // nadir (in same year as measurement)
  const nadirDate = new Date(d.getFullYear(), 0, 1); nadirDate.setDate(nadirDay);
  const nadirDateTxt = dateFmtMonthDay(nadirDate);
  const nadirNgTxt   = `${LRI}${nadirVal.toFixed(1)}${NBSP}${STR[LANG].unitNg}${PDI}`;
  const nadirNmolTxt = `(${LRI}${toNmol(nadirVal).toFixed(0)}${NBSP}${STR[LANG].unitNmol}${PDI})`;
  ctx.fillText(`${STR[LANG].nadir} • ${nadirDateTxt}`, Xn, y0 + 2);
  ctx.font=boldFont;
  ctx.fillText(nadirNgTxt,   Xn, y0 + 16);
  ctx.font=normalFont;
  ctx.fillText(nadirNmolTxt, Xn, y0 + 30);

  // axis labels
  ctx.save();
  ctx.fillStyle='#111';
  ctx.textAlign='center';
  ctx.textBaseline='bottom';

  // remove the left y-axis legend on small screens
  if (!isSmall) {
    ctx.fillText(STR[LANG].axisX, (x0 + x1) / 2, H - 6);
    ctx.translate(rtl ? W-16 : 16, (y0 + y1) / 2);
    ctx.rotate(rtl ? Math.PI/2 : -Math.PI / 2);
    ctx.fillText(STR[LANG].axisY, 0, 0);
  }
  ctx.restore();
  
  // Example call near the end of draw()
  if (window._logPlotUpdate) {
  const unit = document.querySelector('input[name="unit"]:checked')?.value || 'ng';
  window._logPlotUpdate({
    unit,
    lang: document.documentElement.lang,
    // keep it small: round values
    y_max: Math.round(yMax),
  });
}

}

/* ---------- UI wiring ---------- */
function updateUnitHint(){
  const unit = document.querySelector('input[name="unit"]:checked').value;
  let v_in = parseFloat(document.getElementById('vitd').value || "0");
  const hint = document.getElementById('unitHint');
  if (unit==='ng') hint.textContent = `= ${(v_in*2.5).toFixed(1)} ${STR[LANG].unitNmol}`;
  else hint.textContent = `= ${(toNg(v_in)).toFixed(1)} ${STR[LANG].unitNg}`;
}

// language switch
document.getElementById('langSel').addEventListener('change', (e)=>{
  applyLang(e.target.value);
});

// live reactive inputs
['vitd','p_const','p_sin1','p_cos1','p_sin2','p_cos2'].forEach(id=>{
  document.getElementById(id).addEventListener('input', ()=>{ updateUnitHint(); draw(); });
});
document.querySelectorAll('input[name="unit"]').forEach(r => r.addEventListener('change', ()=>{ updateUnitHint(); draw(); }));
document.getElementById('measureDate').addEventListener('change', draw);
// Initial sizing
window.addEventListener('load', sizeCanvasForViewport);
window.addEventListener('resize', sizeCanvasForViewport);

// If you already use a ResizeObserver for the canvas container, also do:
const ro = new ResizeObserver(() => sizeCanvasForViewport());
ro.observe(document.documentElement); // or observe the wrap/card above the canvas

// If language/unit changes affect top layout, hook them too:
document.getElementById('langSel')?.addEventListener('change', sizeCanvasForViewport);
document.getElementById('unitGroup')?.addEventListener('change', sizeCanvasForViewport);

(function(){
  const input   = document.getElementById('vitd');

  const modal  = document.getElementById('vitd-modal');
  const dialog = modal.querySelector('.vd-dialog');
  const slider = document.getElementById('vitd-slider');
  const ticks  = document.getElementById('vd-ticks');
  const live   = document.getElementById('vd-live');
  const unitLb = document.getElementById('vd-unit-label');

  const btnOk  = document.getElementById('vd-ok');
  const btnX   = modal.querySelector('.vd-close');
  const decBtn = document.getElementById('vd-dec');
  const incBtn = document.getElementById('vd-inc');

  // Helpers for unit radio group
  const getUnit = () =>
    document.querySelector('input[name="unit"]:checked')?.value || 'ng';

  const onUnitChange = (fn) => {
    // one listener on the container to catch any radio change
    document.getElementById('unitGroup')?.addEventListener('change', fn);
  };

  // Phone gate: only open modal on phones
  const mq = window.matchMedia('(max-width: 640px) and (pointer: coarse)');
  const isPhone = () => mq.matches;

  const getMaxByUnit = () => (getUnit() === 'nmol' ? 170 : 70);
  const getStep = () => (input.step === 'any' ? 1 : Number(input.step) || 1);

  let isOpen = false;

  const clamp = (v, maxV) => Math.min(maxV, Math.max(0, v));

  function buildTicks(maxV){
    // build ticks every 10 up to maxV (cap count)
    const step = maxV <= 70 ? 10 : 20; // fewer labels for long range
    const parts = [];
    for (let v = 0; v <= maxV; v += step) {
      parts.push('<option value="' + v + '"></option>');
    }
    // ensure exact max tick
    if (parts.length === 0 || !parts[parts.length - 1].includes('value="' + maxV + '"')) {
      parts.push('<option value="' + maxV + '"></option>');
    }
    ticks.innerHTML = parts.join('');
  }

    // Keep slider + number input limits in sync with the selected unit
  function syncSliderToUnit(){
    const unit = getUnit();
    const maxV = getMaxByUnit();
    slider.max = String(maxV);
    input.max  = String(maxV);
    buildTicks(maxV);
    unitLb.textContent = unit === 'nmol' ? 'nmol/L' : 'ng/mL';
    // clamp and mirror value
    const v = clamp(+input.value || 0, maxV);
    input.value = v;
    slider.value = v;
    live.textContent = slider.value;
  }

  // When the radio changes, update limits and, if the modal is closed, apply immediately
  onUnitChange(() => {
    syncSliderToUnit();
    if (!isOpen) applyToInput(); // updates the number field and triggers your draw()
    updateUnitHint();            // refreshes the "= xx nmol" hint
    sizeCanvasForViewport();     // if layout depends on labels width
  });

  // Also guard manual typing in the number input against the current max
  input.addEventListener('input', () => {
    const maxV = getMaxByUnit();
    if (+input.value > maxV) input.value = String(maxV);
  });

  function openModal() {
    if (isOpen) return;
    isOpen = true;
    syncSliderToUnit();
    modal.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    slider.focus({preventScroll:true});
  }

  function applyToInput(){
    const maxV = getMaxByUnit();
    const v = clamp(+slider.value || 0, maxV);
    input.value = v;
    input.dispatchEvent(new Event('input',  {bubbles:true}));
    input.dispatchEvent(new Event('change', {bubbles:true}));
  }

  function closeModal(apply){
    if (!isOpen) return;
    if (apply) applyToInput();
    modal.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
    isOpen = false;
    input.blur();
  }

  // Open on click only on phones
  input.addEventListener('click', (e) => {
    if (!isPhone()) return;
    e.preventDefault();
    openModal();
  });

  // Update live readout
  slider.addEventListener('input', () => {
    live.textContent = slider.value;
  });

  // +/- buttons
  incBtn.addEventListener('click', () => {
    const maxV = getMaxByUnit();
    const step = getStep();
    slider.value = clamp(+slider.value + step, maxV);
    slider.dispatchEvent(new Event('input', {bubbles:true}));
  });
  decBtn.addEventListener('click', () => {
    const maxV = getMaxByUnit();
    const step = getStep();
    slider.value = clamp(+slider.value - step, maxV);
    slider.dispatchEvent(new Event('input', {bubbles:true}));
  });

  // Apply on OK and on X (as requested)
  btnOk.addEventListener('click', () => closeModal(true));
  btnX.addEventListener('click',  () => closeModal(true));

  // Backdrop click cancels
  modal.addEventListener('click', (e) => {
    if (!dialog.contains(e.target)) closeModal(false);
  });

  // If device stops matching, auto-close
  mq.addEventListener('change', () => {
    if (!isPhone() && isOpen) closeModal(false);
  });
})();

// init
(function init(){
  // default date = today (local)
  const dateEl = document.getElementById('measureDate');
  if (dateEl) {
    // valueAsDate respects local time and avoids timezone off-by-one
    dateEl.valueAsDate = new Date();
  }

  // set initial language (browser or ?lang=)
  document.getElementById('langSel').value = LANG;
  applyLang(LANG);

  new ResizeObserver(draw).observe(document.getElementById('plot'));
  sizeCanvasForViewport();
})();


</script>
</body>
</html>
