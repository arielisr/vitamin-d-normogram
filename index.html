<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Vitamin D Calendar Adjustment</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<style>
:root{
  --bg:#ffffff; --card:#fff; --ink:#1f2937; --muted:#6b7280;
  --fieldw: 5ch;           /* compact inputs */
  --coefw: 110px;           /* coefficient field width */
  --wrapw: 1100px;          /* page width */
}

/* Page + wraps */
body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; color:var(--ink); background:#ffffff; }
.wrap{ max-width:var(--wrapw); margin:0 auto; padding:0 16px; }
.wrap.wrap--banner{ margin-top:4px !important; }
.wrap + .wrap{ margin-top:0 !important; margin-bottom:0 !important; }
.card{ background:var(--card); border-radius:14px; box-shadow:0 6px 20px rgba(0,0,0,.06); padding:16px; margin:0; }

/* Banner */
.banner-wrap{ position:relative; }
.hero{ width:100%; height:auto; display:block; border-radius:10px; }
.banner-title{
  position:absolute; left:50%; top:30%; transform:translate(-50%,-50%);
  color:#fff; font-weight:700; text-align:center; line-height:1.15;
  text-shadow:0 2px 8px rgba(0,0,0,.45);
  font-size:clamp(20px,3vw,40px);
  padding:6px 10px; pointer-events:none; white-space:pre-wrap;
}
@media (max-width:480px){
  .banner-title{
    font-size:clamp(16px,6vw,24px); /* lower max on small screens */
    line-height:1.1;                /* tighten lines a bit */
    padding:4px 8px;                /* trim padding */
    max-width:92vw;                 /* avoid long wraps */
    white-space:normal;             /* let it wrap more naturally */
    text-wrap:balance;              /* nicer line breaks where supported */
  }
}
.banner-lang{ position:absolute; top:8px; right:12px; z-index:2; }
.banner-lang select{
  font-size:14px; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px;
  background:rgba(255,255,255,0.9); backdrop-filter:blur(2px);
}
.visually-hidden{ position:absolute!important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

/* Neutralize any legacy grid wrapper so it doesn't affect layout */
.grid-top{ display:contents; }

/* Fields */
.field{ display:flex; flex-direction:column; align-items:flex-start; min-width:0; }
.field label{ font-size:13px; color:var(--muted); margin-bottom:4px; }
.field input[type="number"],
.field input[type="date"]{
  width:var(--fieldw); max-width:100%; font-size:16px; padding:6px 8px;
  border:1px solid #e5e7eb; border-radius:10px; font-variant-numeric:tabular-nums; font-feature-settings:"tnum" 1;
}
.field input[type="date"]{ width:112px; }
.hint{ color:var(--muted); font-size:12px; margin-top:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

/* Toolbar: single line; scrolls horizontally if too tight (no overlap) */
.toolbar.one-line{
  display:flex; align-items:flex-end; gap:12px;
  flex-wrap:nowrap; overflow-x:auto; -webkit-overflow-scrolling:touch;
}

/* Keep children from shrinking into each other */
.toolbar.one-line > .field{ flex:0 0 auto; min-width:0; }

/* Lock the value + radios together on ONE line as a single chunk */
.field-row{
  display:inline-grid;
  grid-auto-flow:column;
  grid-auto-columns:max-content;
  align-items:end;
  gap:8px;
  white-space:nowrap;   /* absolutely no internal wrapping */
}

/* Radios inline, no wrap */
.radio{ display:inline-flex; gap:10px; flex-wrap:nowrap; }
.radio label{ white-space:nowrap; display:flex; align-items:center; gap:6px; }

/* Push the date block to the far right and prevent it from shrinking over radios */
.field--date{ margin-left:auto; flex:0 0 auto; white-space:nowrap; }
html[dir="rtl"] .field--date{ margin-left:0; margin-right:auto; }

/* Canvas/footer */
canvas{ width:100%; height:auto; background:#fff; border-radius:12px; display:block; }
.footer-ribbon{ width:100%; display:block; margin-top:18px; border-radius:10px; }
.radio {
  display: flex;
  flex-direction: column;   /* vertical */
  align-items: flex-start;  /* left-align labels (right in RTL automatically) */
  gap: 4px;                 /* space between rows */
}
/* RTL minor tweaks */
html[dir="rtl"] .toolbar.one-line{ direction:rtl; }

/* Modal shell */
.vd-modal {
  position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
  background: rgba(0,0,0,.4); z-index: 9999;
}
.vd-modal[aria-hidden="false"] { display: flex; }

/* Dialog card */
.vd-dialog {
  width: min(92vw, 420px); background: #fff; color:#111; border-radius: 14px;
  box-shadow: 0 10px 30px rgba(0,0,0,.25); overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
}
.vd-header {
  display:flex; align-items:center; justify-content:space-between;
  padding: 10px 14px; background:#f6f7fb; border-bottom:1px solid #e5e7eb;
  font-weight:600;
}
.vd-close { background:none; border:0; font-size:20px; line-height:1; padding:6px; cursor:pointer; }
.vd-body { padding: 16px; }
.vd-value { text-align:center; font-size: 22px; margin-bottom: 10px; }
#vitd-slider { width: 100%; }
.vd-actions {
  display:flex; gap:8px; justify-content:center; margin-top:14px;
}
.vd-actions button {
  padding:10px 14px; border-radius:10px; border:1px solid #e5e7eb; background:#fff; font-size:16px;
}
.vd-primary { background:#111; color:#fff; border-color:#111; }

@media (max-width: 640px){
  html, body { margin:0; padding:0; }

  /* Kill container gutters and width caps */
  .wrap, .container, .section {
    max-width: none;
    padding: 0;
    margin: 0;
  }

  /* Respect iOS notches when you DO want tiny side gutters */
  .wrap, .container, .section, header, footer {
    padding-left: env(safe-area-inset-left);
    padding-right: env(safe-area-inset-right);
  }

  /* Optional: make specific blocks bleed full width */
  .fullbleed {
    width: 100vw;
    margin-left: calc(50% - 50vw);
    margin-right: calc(50% - 50vw);
  }

  /* If your banner had inner padding, trim it */
  .banner, .banner-title { padding-left: 0; padding-right: 0; }
}
</style>
</head>
<script>window.process = window.process || { env: {} };</script>
<script type="module">
  import { initializeApp }     from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
  import { getAnalytics, isSupported, logEvent, setUserProperties }
    from "https://www.gstatic.com/firebasejs/10.12.4/firebase-analytics.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCrm86rYfHXbe2gpzDbvkl2wEWnzcDqi28",
    authDomain: "arielisr.github.io",
    projectId: "vitamin-d-normogram",
    storageBucket: "covidest.appspot.com",
    messagingSenderId: "1028167923136",
    appId: "1:1028167923136:web:1ca1fc0177ebd0d3b70425",
    measurementId: "G-8HCTDJGBS1"
  };

  const app = initializeApp(firebaseConfig);

  // Guard: analytics only on supported, secure origins
  const analytics = (await isSupported()) ? getAnalytics(app) : null;

  // Helper safe-log
  function log(name, params){ if (analytics) logEvent(analytics, name, params); }

  // Set useful user properties (no PII)
  const langSel = document.getElementById('langSel');
  if (analytics && langSel) {
    setUserProperties(analytics, { ui_lang: langSel.value });
    langSel.addEventListener('change', () => setUserProperties(analytics, { ui_lang: langSel.value }));
  }

  // Log initial page_view (GA4 usually auto-logs; harmless to send once)
  log('page_view', { page_title: document.title });

  // Example: log interactions (hook into your existing inputs)
  const vitInput = document.getElementById('vitd');
  const dateInput = document.getElementById('measureDate');
  const unitRadios = document.querySelectorAll('input[name="unit"]');

  vitInput?.addEventListener('change', () => log('vitd_value_change', {
    value_ng_or_nmol: parseFloat(vitInput.value) || 0
  }));
  dateInput?.addEventListener('change', () => log('measurement_date_change', {}));
  unitRadios.forEach(r => r.addEventListener('change', (e) => log('unit_toggle', { unit: e.target.value })));

  // Optional: log each redraw (keep params small, no PII)
  window._logPlotUpdate = (params) => log('plot_update', params);
</script>

<body>

  <!-- Banner with title and language switch -->
  <div class="wrap wrap--banner">
    <div class="banner-wrap">
      <img class="hero" alt="Leumit Research banner" src="https://arielisr.github.io/lri-newsletter/graphics/leumit_banner_300DPI.png">
      <div class="banner-title" id="bannerTitle">Vitamin D Calendar Adjustment</div>
      <div class="banner-lang">
        <label for="langSel" class="visually-hidden">Language</label>
        <select id="langSel" aria-label="Language">
          <option value="en">English</option>
          <option value="he">עברית</option>
        </select>
      </div>
    </div>
  </div>

  <div class="wrap">
  <div class="card">
    <div class="toolbar one-line">
      <div class="field">
        <label id="lblValue">25(OH)D value</label>
        <div class="field-row">
			<input id="vitd" type="number" min="0" max="70" step="1" value="25" inputmode="decimal">
          <div class="radio" id="unitGroup">
            <label><input type="radio" name="unit" value="ng" checked> <span id="unitNg">ng/mL</span></label>
            <label><input type="radio" name="unit" value="nmol"> <span id="unitNmol">nmol/L</span></label>
          </div>
        </div>
        <div class="hint" id="unitHint">= 50.0 nmol/L</div>
      </div>
<!-- Modal slider -->
	<div id="vitd-modal" class="vd-modal" aria-hidden="true" role="dialog" aria-labelledby="vd-title">
	  <div class="vd-dialog">
		<div class="vd-header">
		  <div id="vd-title">Set Vitamin D</div>
		  <button type="button" class="vd-close" aria-label="Close">X</button>
		</div>

		<div class="vd-body">
		  <div class="vd-value"><span id="vd-live">25</span> <span id="vd-unit-label">ng/mL</span></div>
		  <input id="vitd-slider" type="range" min="0" max="70" step="1" value="25" list="vd-ticks">
		  <datalist id="vd-ticks"></datalist>
		  <div class="vd-actions">
			<button type="button" id="vd-dec">-</button>
			<button type="button" id="vd-inc">+</button>
			<button type="button" id="vd-ok" class="vd-primary">OK</button>
		  </div>
		</div>
	  </div>
	</div>
      <div class="field">
        <label id="lblDate">Date of measurement</label>
        <input id="measureDate" type="date">
        <div class="hint" id="hintDate">Anchors the seasonal curve</div>
      </div>
    </div>

      <details hidden>
        <summary id="advTitle">Advanced: seasonal coefficients</summary>
        <div class="coef-grid" style="margin-top:8px;">
          <div class="coef"><label id="coef_const">const</label>        <input id="p_const" type="number" step="0.000001" value="2.86504436"></div>
          <div class="coef"><label id="coef_sin1">season_sin</label>    <input id="p_sin1"  type="number" step="0.000001" value="-0.19078822"></div>
          <div class="coef"><label id="coef_cos1">season_cos</label>    <input id="p_cos1"  type="number" step="0.000001" value="-0.17079543"></div>
          <div class="coef"><label id="coef_sin2">season_sin2</label>   <input id="p_sin2"  type="number" step="0.000001" value="0.01443204"></div>
          <div class="coef"><label id="coef_cos2">season_cos2</label>   <input id="p_cos2"  type="number" step="0.000001" value="0.00978268"></div>
        </div>
        <div class="hint" id="advHint">Curve = exp(const + a·sin(θ) + b·cos(θ) + c·sin(2θ) + d·cos(2θ)), θ=2π·day/365.25. Your input rescales the curve at the chosen date.</div>
      </details>
      <canvas id="plot" width="1200" height="520"></canvas>
      <div class="hint" id="bandsHint">Bands: Very-severe &lt;5, Severe 5–10, Moderate 10–15, Mild 15–20, Insufficiency 20–30, Sufficiency ≥30 ng/mL</div>
    <img class="footer-ribbon" alt="Leumit Research Institute ribbon" src="https://arielisr.github.io/lri-newsletter/graphics/leumit_tailer_300DPI.png">
  </div>

<script>
/* ---------- i18n strings ---------- */
const STR = {
  en: {
    docTitle: 'Vitamin D Calendar Adjustment',
    bannerTitle: 'Vitamin D Calendar Adjustment',
    lblValue: '25(OH)D value',
    unitNg: 'ng/mL',
    unitNmol: 'nmol/L',
    lblDate: 'Date of measurement',
    hintDate: 'Anchors the seasonal curve',
    advTitle: 'Advanced: seasonal coefficients',
    advHint: 'Curve = exp(const + a·sin(θ) + b·cos(θ) + c·sin(2θ) + d·cos(2θ)), θ=2π·day/365.25. Your input rescales the curve at the chosen date.',
    coef_const: 'const',
    coef_sin1: 'season_sin',
    coef_cos1: 'season_cos',
    coef_sin2: 'season_sin2',
    coef_cos2: 'season_cos2',
    bandsHint: 'Bands: Very-severe <5, Severe 5–10, Moderate 10–15, Mild 15–20, Insufficiency 20–30, Sufficiency ≥30 ng/mL',
    bands: [
      { key:'verySevere', label:'Very-severe deficiency' },
      { key:'severe',     label:'Severe deficiency' },
      { key:'moderate',   label:'Moderate deficiency' },
      { key:'mild',       label:'Mild deficiency' },
      { key:'insuff',     label:'Insufficiency' },
      { key:'suff',       label:'Sufficiency' }
    ],
    axisX: 'Day of year',
    axisY: '25-OH Vitamin D (ng/mL)',
    nadir: 'Nadir'
  },
  he: {
    docTitle: 'ויטמין די מתוקן לתאריך השנה',
    bannerTitle: 'ויטמין די מתוקן לתאריך השנה',
    lblValue: 'ערך 25(OH)D',
    unitNg: 'נג/מ״ל',
    unitNmol: 'ננומול/ל׳',
    lblDate: 'תאריך המדידה',
    hintDate: 'מעגן את העקומה העונתית',
    advTitle: 'מתקדם: מקדמי עונתיות',
    advHint: 'עקומה = exp(const + a·sin(θ) + b·cos(θ) + c·sin(2θ) + d·cos(2θ)), ‏θ=2π·יום/365.25. הערך שהוזן מתאים את העקומה לתאריך.',
    coef_const: 'const',
    coef_sin1: 'season_sin',
    coef_cos1: 'season_cos',
    coef_sin2: 'season_sin2',
    coef_cos2: 'season_cos2',
    bandsHint: 'תחומים: חוסר חמור מאוד <5, חוסר חמור 5–10, חוסר בינוני 10–15, חוסר קל 15–20, חוסר 20–30, מספק ≥30 נג/מ״ל',
    bands: [
      { key:'verySevere', label:'חוסר חמור מאוד' },
      { key:'severe',     label:'חוסר חמור' },
      { key:'moderate',   label:'חוסר בינוני' },
      { key:'mild',       label:'חוסר קל' },
      { key:'insuff',     label:'חוסר' },
      { key:'suff',       label:'מספק' }
    ],
    axisX: 'יום בשנה',
    axisY: '25-OH ויטמין D (נג/מ״ל)',
    nadir: 'שפל'
  }
};

/* ---------- locale helpers ---------- */
function getInitialLang(){
  const urlLang = new URLSearchParams(location.search).get('lang');
  if (urlLang === 'he' || urlLang === 'en') return urlLang;
  return (navigator.language || '').toLowerCase().startsWith('he') ? 'he' : 'en';
}
let LANG = getInitialLang();

function applyLang(lang){
  LANG = (lang === 'he') ? 'he' : 'en';
  const S = STR[LANG];
  document.documentElement.lang = LANG;
  document.documentElement.dir  = (LANG === 'he') ? 'rtl' : 'ltr';
  document.title = S.docTitle;

  const set = (id, v) => { const el = document.getElementById(id); if (el) el.textContent = v; };
  set('bannerTitle', S.bannerTitle);
  set('lblValue', S.lblValue);
  set('unitNg', S.unitNg);
  set('unitNmol', S.unitNmol);
  set('lblDate', S.lblDate);
  set('hintDate', S.hintDate);
  set('advTitle', S.advTitle);
  set('advHint', S.advHint);
  set('coef_const', S.coef_const);
  set('coef_sin1', S.coef_sin1);
  set('coef_cos1', S.coef_cos1);
  set('coef_sin2', S.coef_sin2);
  set('coef_cos2', S.coef_cos2);
  set('bandsHint', S.bandsHint);

  const sel = document.getElementById('langSel');
  if (sel && sel.value !== LANG) sel.value = LANG;

  updateUnitHint();
  draw();
}

/* ---------- plotting utilities ---------- */
const toNmol = ng => ng * 2.5;
const toNg   = nmol => nmol / 2.5;

function dayOfYear(d){
  const dt = new Date(d.getFullYear(), 0, 0);
  const diff = d - dt + ((dt.getTimezoneOffset()-d.getTimezoneOffset())*60*1000);
  return Math.floor(diff / (1000*60*60*24)); // 1..366
}
function dateFmtMonthDay(date){
  return new Intl.DateTimeFormat(LANG, { month: 'short', day: 'numeric' }).format(date);
}
function monthLabelFor(monthIndex, year){
  const d = new Date(year, monthIndex, 1);
  return new Intl.DateTimeFormat(LANG, { month: 'short' }).format(d);
}

function buildSeason(days, p){
  const out = new Array(days.length);
  for (let i=0;i<days.length;i++){
    const t = days[i];
    const theta = 2*Math.PI*t/365.25;
    const valLog = p.const + p.sin1*Math.sin(theta) + p.cos1*Math.cos(theta)
                 + p.sin2*Math.sin(2*theta) + p.cos2*Math.cos(2*theta);
    out[i] = Math.exp(valLog);
  }
  return out;
}
function deviceScale(canvas, ctx){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = canvas.getBoundingClientRect();
  canvas.width  = Math.round(rect.width * dpr);
  canvas.height = Math.round(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
function clamp(v, lo, hi){ return Math.min(Math.max(v, lo), hi); }

/* ---------- drawing ---------- */
const cv = document.getElementById('plot');
const ctx = cv.getContext('2d');

const PHONE_BP = 680; // px

function sizeCanvasForViewport() {
  const isSmall = window.matchMedia(`(max-width:${PHONE_BP}px)`).matches;
  if (!isSmall) {
    // desktop/tablet: let canvas be intrinsic; clear explicit height
    cv.style.height = '';
    draw();
    return;
  }

  // Remaining viewport below the canvas top
  const rect = cv.getBoundingClientRect();
  const safeBottom = 200 + (window.visualViewport ? (window.visualViewport.height - window.innerHeight) : 0);
  const remaining = Math.max(0, window.innerHeight - rect.top - safeBottom);

  // Target about 50% of the remaining height (with a floor)
  const targetH = Math.max(400, Math.round(remaining * 0.4));
  cv.style.height = `${targetH}px`;

  // Redraw using the new clientHeight
  draw();
}

function draw(){
  const S = STR[LANG];
  deviceScale(cv, ctx);
  const W = cv.clientWidth, H = cv.clientHeight;

  const rtl = (LANG === 'he');
  const isSmall = window.matchMedia('(max-width: 500px)').matches;

  // margins:
  // - normal: extra outer margin for band labels (right in LTR, left in RTL)
  // - small: tighter margins; no band labels or y-axis legend
  const m = isSmall
    ? (rtl ? { l: 32, r: 16, t: 28, b: 40 } : { l: 36, r: 16, t: 28, b: 40 })
    : (rtl ? { l: 140, r: 56, t: 34, b: 46 } : { l: 56,  r: 140, t: 34, b: 46 });

  const x0 = m.l, x1 = W - m.r, y0 = m.t, y1 = H - m.b;
  const plotW = x1 - x0, plotH = y1 - y0;

  ctx.clearRect(0,0,W,H);

  // inputs
  const unitSel = document.querySelector('input[name="unit"]:checked').value;
  const v_in = parseFloat(document.getElementById('vitd').value || "0");
  const v_ng = (unitSel === 'ng') ? v_in : toNg(v_in); // ALWAYS compute in ng/mL

  const dateStr = document.getElementById('measureDate').value;
  const d = dateStr ? new Date(dateStr) : new Date();
  let doy = clamp(dayOfYear(d), 1, 365);

  const p = {
    const: parseFloat(document.getElementById('p_const').value || "2.86504436"),
    sin1:  parseFloat(document.getElementById('p_sin1').value  || "-0.19078822"),
    cos1:  parseFloat(document.getElementById('p_cos1').value  || "-0.17079543"),
    sin2:  parseFloat(document.getElementById('p_sin2').value  || "0.01443204"),
    cos2:  parseFloat(document.getElementById('p_cos2').value  || "0.00978268")
  };

  const days = Array.from({length:365}, (_,i)=>i+1);
  const base = buildSeason(days, p);
  const baseAt = base[doy-1];
  const scale = (baseAt>0 ? v_ng / baseAt : 1);
  const curve = base.map(z => z*scale);

  // nadir (projected day)
  let nadirDay = 1, nadirVal = curve[0];
  for (let i=1;i<curve.length;i++){
    if (curve[i] < nadirVal){ nadirVal = curve[i]; nadirDay = i+1; }
  }

  const yMax = Math.max(50, Math.ceil(Math.max(...curve, 30)/5)*5);
  const yMin = 0;

  const xMap = x => x0 + (x-1)/(365-1)*plotW;
  const yMap = y => y1 - (y-yMin)/(yMax-yMin)*plotH;

  // background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(x0,y0,plotW,plotH);

  // bands (ng/mL thresholds)
  const bands = [
    {y0:0, y1:5,  key:'verySevere', color:'rgba(200, 30, 30, 0.18)'},
    {y0:5, y1:10, key:'severe',     color:'rgba(220, 60, 40, 0.18)'},
    {y0:10,y1:15, key:'moderate',   color:'rgba(230, 120, 40, 0.18)'},
    {y0:15,y1:20, key:'mild',       color:'rgba(240, 170, 40, 0.18)'},
    {y0:20,y1:30, key:'insuff',     color:'rgba(170, 200, 60, 0.18)'},
    {y0:30,y1:yMax, key:'suff',     color:'rgba(80, 170, 80, 0.14)'}
  ];
  bands.forEach(b=>{
    const yy0 = Math.max(yMin, b.y0), yy1 = Math.min(yMax, b.y1);
    if (yy1<=yy0) return;
    ctx.fillStyle = b.color;
    ctx.fillRect(x0, yMap(yy1), plotW, Math.abs(yMap(yy0)-yMap(yy1)));
  });

  // boundaries
  const boundaries = [5,10,15,20,30];
  boundaries.forEach(y=>{
    if (y<yMin || y>yMax) return;
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x0, yMap(y));
    ctx.lineTo(x1, yMap(y));
    ctx.stroke();
  });

  // grid (y major every 5)
  ctx.strokeStyle = 'rgba(0,0,0,0.08)';
  ctx.lineWidth = 1;
  for (let y=0; y<=yMax; y+=5){
    ctx.beginPath();
    ctx.moveTo(x0, yMap(y));
    ctx.lineTo(x1, yMap(y));
    ctx.stroke();
  }

  // month verticals & centered labels, localized
  const monthStarts = [1,32,60,91,121,152,182,213,244,274,305,335,366];
  ctx.strokeStyle = 'rgba(0,0,0,0.2)';
  ctx.setLineDash([4,5]);
  for (let i=0;i<monthStarts.length-1;i++){
    ctx.beginPath();
    ctx.moveTo(xMap(monthStarts[i]), y0);
    ctx.lineTo(xMap(monthStarts[i]), y1);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // axes: bottom + vertical (left in LTR, right in RTL)
  ctx.strokeStyle = '#111';
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  if (rtl) {
    ctx.moveTo(x1, y0); ctx.lineTo(x1, y1); // right vertical axis
  } else {
    ctx.moveTo(x0, y0); ctx.lineTo(x0, y1); // left vertical axis
  }
  ctx.lineTo(x1, y1); // bottom axis
  ctx.stroke();

    // y ticks & labels: left in LTR, right in RTL
  ctx.fillStyle = '#111';
  ctx.font = (isSmall ? '11px' : '12px') + ' system-ui, Arial';
  ctx.textBaseline = 'middle';
  if (rtl) {
    ctx.textAlign = 'left';
    for (let y=0; y<=yMax; y+=5){
      ctx.fillText(String(y), x1 + 6, yMap(y)); // a bit tighter
    }
  } else {
    ctx.textAlign = 'right';
    for (let y=0; y<=yMax; y+=5){
      ctx.fillText(String(y), x0 - 6, yMap(y));
    }
  }

	const el = document.getElementById('bandsHint');
	if (el) el.hidden = !isSmall; 
  // month labels (localized)
  const yearForLabels = (new Date()).getFullYear();
  ctx.textAlign='center'; ctx.textBaseline='top';
  for (let i=0;i<12;i++){
    const center = 0.5*(monthStarts[i] + monthStarts[i+1]);
    const label = monthLabelFor(i, yearForLabels);
    ctx.fillText(label, xMap(center), y1+8);
  }

  // band labels at outer margin (right in LTR, left in RTL)
  if (!isSmall) {
    ctx.textAlign = rtl ? 'right' : 'left';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#111';
    bands.forEach((b, idx)=>{
      const yy = Math.min((b.y0+b.y1)/2, yMax-0.001);
      if (yy<yMin || yy>yMax) return;
      const label = STR[LANG].bands[idx].label;
      const xText = rtl ? (x0-8) : (x1+8);
      ctx.fillText(label, xText, yMap(yy));
    });
  }

  // curve
  ctx.strokeStyle = '#2457a0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i=0;i<days.length;i++){
    const X = xMap(days[i]), Y = yMap(curve[i]);
    if (i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
  }
  ctx.stroke();

  // markers: measurement day & nadir (projected day)
  const Xd = xMap(doy),   Yd = yMap(curve[doy-1]);
  const Xn = xMap(nadirDay), Yn = yMap(nadirVal);
  function dot(x,y, color){ ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); }
  dot(Xd, Yd, '#2457a0');   // measurement (blue)
  dot(Xn, Yn, '#ef4444');   // nadir/projected (red)

  // top-boundary annotations (month-day only; units on separate lines)
  ctx.fillStyle='#111';
  ctx.font='12px system-ui, Arial';
  ctx.textAlign='center';
  ctx.textBaseline='top';

  // measurement
  const measDateTxt = dateFmtMonthDay(d);
  const measNgTxt   = `${v_ng.toFixed(1)} ${STR[LANG].unitNg}`;
  const measNmolTxt = `${toNmol(v_ng).toFixed(0)} ${STR[LANG].unitNmol}`;
  ctx.fillText(measDateTxt, Xd, y0 + 2);
  ctx.fillText(measNgTxt,   Xd, y0 + 16);
  ctx.fillText(measNmolTxt, Xd, y0 + 30);

  // nadir (in same year as measurement)
  const nadirDate = new Date(d.getFullYear(), 0, 1); nadirDate.setDate(nadirDay);
  const nadirDateTxt = dateFmtMonthDay(nadirDate);
  const nadirNgTxt   = `${nadirVal.toFixed(1)} ${STR[LANG].unitNg}`;
  const nadirNmolTxt = `${toNmol(nadirVal).toFixed(0)} ${STR[LANG].unitNmol}`;
  ctx.fillText(`${STR[LANG].nadir} • ${nadirDateTxt}`, Xn, y0 + 2);
  ctx.fillText(nadirNgTxt,                               Xn, y0 + 16);
  ctx.fillText(nadirNmolTxt,                             Xn, y0 + 30);

  // axis labels
  ctx.save();
  ctx.fillStyle='#111';
  ctx.textAlign='center';
  ctx.textBaseline='bottom';

  // remove the left y-axis legend on small screens
  if (!isSmall) {
    ctx.fillText(STR[LANG].axisX, (x0 + x1) / 2, H - 6);
    ctx.translate(rtl ? W-16 : 16, (y0 + y1) / 2);
    ctx.rotate(rtl ? Math.PI/2 : -Math.PI / 2);
    ctx.fillText(STR[LANG].axisY, 0, 0);
  }
  ctx.restore();
  
  // Example call near the end of draw()
  if (window._logPlotUpdate) {
  const unit = document.querySelector('input[name="unit"]:checked')?.value || 'ng';
  window._logPlotUpdate({
    unit,
    lang: document.documentElement.lang,
    // keep it small: round values
    y_max: Math.round(yMax),
  });
}

}

/* ---------- UI wiring ---------- */
function updateUnitHint(){
  const unit = document.querySelector('input[name="unit"]:checked').value;
  let v_in = parseFloat(document.getElementById('vitd').value || "0");
  const hint = document.getElementById('unitHint');
  if (unit==='ng') hint.textContent = `= ${(v_in*2.5).toFixed(1)} ${STR[LANG].unitNmol}`;
  else hint.textContent = `= ${(toNg(v_in)).toFixed(1)} ${STR[LANG].unitNg}`;
}

// language switch
document.getElementById('langSel').addEventListener('change', (e)=>{
  applyLang(e.target.value);
});

// live reactive inputs
['vitd','p_const','p_sin1','p_cos1','p_sin2','p_cos2'].forEach(id=>{
  document.getElementById(id).addEventListener('input', ()=>{ updateUnitHint(); draw(); });
});
document.querySelectorAll('input[name="unit"]').forEach(r => r.addEventListener('change', ()=>{ updateUnitHint(); draw(); }));
document.getElementById('measureDate').addEventListener('change', draw);
// Initial sizing
window.addEventListener('load', sizeCanvasForViewport);
window.addEventListener('resize', sizeCanvasForViewport);

// If you already use a ResizeObserver for the canvas container, also do:
const ro = new ResizeObserver(() => sizeCanvasForViewport());
ro.observe(document.documentElement); // or observe the wrap/card above the canvas

// If language/unit changes affect top layout, hook them too:
document.getElementById('langSel')?.addEventListener('change', sizeCanvasForViewport);
document.getElementById('unitGroup')?.addEventListener('change', sizeCanvasForViewport);

(function(){
  const input   = document.getElementById('vitd');

  const modal  = document.getElementById('vitd-modal');
  const dialog = modal.querySelector('.vd-dialog');
  const slider = document.getElementById('vitd-slider');
  const ticks  = document.getElementById('vd-ticks');
  const live   = document.getElementById('vd-live');
  const unitLb = document.getElementById('vd-unit-label');

  const btnOk  = document.getElementById('vd-ok');
  const btnX   = modal.querySelector('.vd-close');
  const decBtn = document.getElementById('vd-dec');
  const incBtn = document.getElementById('vd-inc');

  // Helpers for unit radio group
  const getUnit = () =>
    document.querySelector('input[name="unit"]:checked')?.value || 'ng';

  const onUnitChange = (fn) => {
    // one listener on the container to catch any radio change
    document.getElementById('unitGroup')?.addEventListener('change', fn);
  };

  // Phone gate: only open modal on phones
  const mq = window.matchMedia('(max-width: 640px) and (pointer: coarse)');
  const isPhone = () => mq.matches;

  const getMaxByUnit = () => (getUnit() === 'nmol' ? 170 : 70);
  const getStep = () => (input.step === 'any' ? 1 : Number(input.step) || 1);

  let isOpen = false;

  const clamp = (v, maxV) => Math.min(maxV, Math.max(0, v));

  function buildTicks(maxV){
    // build ticks every 10 up to maxV (cap count)
    const step = maxV <= 70 ? 10 : 20; // fewer labels for long range
    const parts = [];
    for (let v = 0; v <= maxV; v += step) {
      parts.push('<option value="' + v + '"></option>');
    }
    // ensure exact max tick
    if (parts.length === 0 || !parts[parts.length - 1].includes('value="' + maxV + '"')) {
      parts.push('<option value="' + maxV + '"></option>');
    }
    ticks.innerHTML = parts.join('');
  }

    // Keep slider + number input limits in sync with the selected unit
  function syncSliderToUnit(){
    const unit = getUnit();
    const maxV = getMaxByUnit();
    slider.max = String(maxV);
    input.max  = String(maxV);
    buildTicks(maxV);
    unitLb.textContent = unit === 'nmol' ? 'nmol/L' : 'ng/mL';
    // clamp and mirror value
    const v = clamp(+input.value || 0, maxV);
    input.value = v;
    slider.value = v;
    live.textContent = slider.value;
  }

  // When the radio changes, update limits and, if the modal is closed, apply immediately
  onUnitChange(() => {
    syncSliderToUnit();
    if (!isOpen) applyToInput(); // updates the number field and triggers your draw()
    updateUnitHint();            // refreshes the "= xx nmol" hint
    sizeCanvasForViewport();     // if layout depends on labels width
  });

  // Also guard manual typing in the number input against the current max
  input.addEventListener('input', () => {
    const maxV = getMaxByUnit();
    if (+input.value > maxV) input.value = String(maxV);
  });

  function openModal() {
    if (isOpen) return;
    isOpen = true;
    syncSliderToUnit();
    modal.setAttribute('aria-hidden', 'false');
    document.body.style.overflow = 'hidden';
    slider.focus({preventScroll:true});
  }

  function applyToInput(){
    const maxV = getMaxByUnit();
    const v = clamp(+slider.value || 0, maxV);
    input.value = v;
    input.dispatchEvent(new Event('input',  {bubbles:true}));
    input.dispatchEvent(new Event('change', {bubbles:true}));
  }

  function closeModal(apply){
    if (!isOpen) return;
    if (apply) applyToInput();
    modal.setAttribute('aria-hidden', 'true');
    document.body.style.overflow = '';
    isOpen = false;
    input.blur();
  }

  // Open on click only on phones
  input.addEventListener('click', (e) => {
    if (!isPhone()) return;
    e.preventDefault();
    openModal();
  });

  // Update live readout
  slider.addEventListener('input', () => {
    live.textContent = slider.value;
  });

  // +/- buttons
  incBtn.addEventListener('click', () => {
    const maxV = getMaxByUnit();
    const step = getStep();
    slider.value = clamp(+slider.value + step, maxV);
    slider.dispatchEvent(new Event('input', {bubbles:true}));
  });
  decBtn.addEventListener('click', () => {
    const maxV = getMaxByUnit();
    const step = getStep();
    slider.value = clamp(+slider.value - step, maxV);
    slider.dispatchEvent(new Event('input', {bubbles:true}));
  });

  // Apply on OK and on X (as requested)
  btnOk.addEventListener('click', () => closeModal(true));
  btnX.addEventListener('click',  () => closeModal(true));

  // Backdrop click cancels
  modal.addEventListener('click', (e) => {
    if (!dialog.contains(e.target)) closeModal(false);
  });

  // If device stops matching, auto-close
  mq.addEventListener('change', () => {
    if (!isPhone() && isOpen) closeModal(false);
  });
})();

// init
(function init(){
  // default date = today (local)
  const dateEl = document.getElementById('measureDate');
  if (dateEl) {
    // valueAsDate respects local time and avoids timezone off-by-one
    dateEl.valueAsDate = new Date();
  }

  // set initial language (browser or ?lang=)
  document.getElementById('langSel').value = LANG;
  applyLang(LANG);

  new ResizeObserver(draw).observe(document.getElementById('plot'));
  sizeCanvasForViewport();
})();


</script>
</body>
</html>
